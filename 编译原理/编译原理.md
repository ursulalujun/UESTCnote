# 编译原理笔记（一）

## 绪论

语言分类：

按理论基础：过程式（命令式、强制式）--冯诺依曼体系结构；函数式（功能）；逻辑式（条件）--数理逻辑谓词运算；对象式--抽象数据结构

四代语言：机器（二进制）；汇编（机器语言符号化）；高级（告诉机器“做什么”和“怎么做”）；超高级（只告诉“做什么”，如SQL）；新一代语言（函数式、对象式和逻辑式）

绑定：一个实体（对象）与某种属性建立某种联系的过程

变量的属性

- 作用域（大多是静态）：可访问该变量的程序范围
- 生存期：一个存储区绑定于变量的时间区间，分配，C、C++是动态分配，可以隐式（进入变量的作用域时自动获得）或者显式（new）分配
- 值（动态）
- 类型

编译之前或编译时能确定的属性称为静态，运行时才能确定的属性称为动态

动态绑定的语言一般采用解释，静态一般采用编译

虚拟机：由实际机器加软件实现的机器，有自己的机器语言，比如字节码就可以看出是java虚拟机的机器语言



程序单元：在执行过程中独立的调用单位，被调用、运行的过程叫激活

运行时，单元=代码段+活动记录，是单元实例

活动记录要在运行过程中生成和释放

引用环境：一个程序单元可以引用的局部和非局部变量



语言设计过程：首先是适用于特殊功能的语言，然后是集成



## 数据类型

（用户自定义类型、概念、举例，5分简答题，后面的记概念，不用画图）

数据类型：对存储器中数据的抽象，定义了一组值的集合和一组操作

内部类型

用户定义类型（也是聚合）

- 笛卡尔积--记录、结构

- 有限映射--数组、Map

- 序列（由任意多个类型相同的数据项构成）--字符串、顺序文件

- 递归--各类树、指针

- 判定或（二选一）--C语言 union，多个变量共用一个c存储空间，空间长度为最大变量的长度，修改一个变量就会影响到其他的；Pascal变体记录，含一个boolean变量，根据它判断后半部分的类型


  ```c
  struct{
    char name[20];
    int age;
    char sex;
    // 针对教室和学生选择填写成绩或者科目，二选一
    union{
        float score;
        char course[20];
    } sc;
  } bodys[TOTAL];
  ```

- 幂集--总集合的任意子集

结构变量指的就是聚合类型，非结构化就是基本类型

枚举是非结构类型，是规定枚举类型可能的值，以及它们的顺序，然后具体的变量只能取一个值



抽象数据类型

内部类型和用户自定义类型是两个层次的抽象，抽象数据类型是以它们为基本表示的 更高层次的抽象，具有信息隐蔽、封装、继承等特性，基本表示不可见，比如C++、java的类                   



类型检查：数据对象的类型和使用的操作是否匹配

强类型、弱类型、无类型（有些时候强弱类型的概念并不等同于动态还是静态检查，虽然课本是这样定义的）

java、c++类型检查全部在编译时完成（静态），python在运行时完成类型检查



类型转换：收缩、拓展

两个变量能相互赋值则称为相容

两个变量的类型名相同为名字等价

两个变量的类型具有相同的结构称为结构等价



实现模型

描述符->存储区（数据对象）

Pascal：描述符记录变量名、类型、指向存储区的指针，数组还要记录数组名、成分类型、下标类型、上下界、单元个数

实现二维数组或者结构体中的数组就用描述符里的一个单元指向另一个描述数组的描述符



## 控制结构

（选填题）

注意流程图的Y和N不能漏写

语句级

顺序、选择、循环

单元级

- 显式调用

  实参与形参的绑定：位置绑定、关键词绑定

  副作用： 对绑定的非局部变量（绑定在别的程序单元的活动记录中）进行修改时，将产生副作用

  eg: w=f(x,y)+z，若f的调用造成z的改变，则z+f(x,y)!=f(x,y)+z

  降低可读性；破坏运算律；影响编译优化

  别名：单元激活期间，两个变量共享同一数据对象，别名会造成swap等程序出问题

- 异常处理（即隐式调用）

- 协同程序：单元之间彼此显示地激活（通过命令），交错执行

- 并发单元：不存在调用和返回的概念

  

## 程序语言的设计

### 语言

语言由语法和语义组成

语法包括词法规则（什么样的字符串可以构成有效符号，eg. 标识符规则）和各语法单位的形成规则

描述语言的方法：生成（文法）；识别（识别图）

识别图：圆形 终结符；方框 非终结符；串接并接；定义一个非终结符的语法图只能有一个出口和一个入口；回溯

下图不是很严谨，α表示非终结符，应该写成N更好，所以最后一定是会被换成γ的，最后生成的是γβ^n^

![image-20230314115014422](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230314115014422.png)

语义规定语法单位的含义和正确性

还没有被普遍接受的工具，常用自然语言描述

GAM抽象机

### 文法

文法是语法的形式描述，根据文法产生语言

BNF：G=(N, T, S, P)  N 非终结符 < > ；T 终结符；P 规则，产生式的非空有限集合；S 开始符号，属于非终结符（规则的左半边，加<>）

产生式规则 ->，推导过程 =>

大写 代替尖角符号，表示非终结符；小写 表示终结符；希腊字母表示两者的集合（或）；ε表示空符号串

左递归：A->Aβ；右递归：A->βA

0型文法（短语结构文法）

α->β，产生式左端至少有一个非终结符（产生空字符串除外）

表达的能力相当于图灵机，是最泛的

递归可枚举？

1型文法（上下文相关文法）

|α|<=|β|

等价定义：αAβ->αωβ，其中A为非终结符

每次一定有一个非终结符产生一个以上的终结符

2型文法（上下文无关文法）

A->β，左边仅有一个非终结符，β∈N∪T，所以不受上下文限制

3型文法（正则文法）

右线性文法：A->aB或A->a，a∈T，B可以等于A，即可以表示递归

左线性即A->Ba，针对每个右线性文法，一定能找到与之等价的左线性文法

文法等价就是能产生相同的语言



推导 => 逆过程称为归约，由一步得到称为直接；=>+，推导一步以上，=>0，经过0步推导，即相等，=>* 经过任意步推导

最右推导（规范推导）：每次被替换的非终结符均是最右边的，逆过程称为最左归约

为编译器设置固定的推导规则：每次换哪个？怎么换？什么时候结束？

最右推导（规范推导）

句型：由开始符推导出来的符号串，开始本身也是一个句型，是由0步推导出的；句子：最终生成的，只含终结符；语言：由所有**句子**组成的集合



<font color='cornflowerblue'>T：文法与语言</font>

推导语言

多迭代几次找规律

逆推文法

次数一样的拆成一坨

把m>=k，把k代入进去检查一下

![image-20230315153306594](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230315153306594.png)



#### 语法树

二义文法：一个文法存在**某个句子**有多于一个的语法树

二义文法产生的语言不一定有二义性，一个有二义性的文法和一个没有的文法可能产生相同的语言。存在先天二义语言；即，每个产生它的文法都是二义的



<font color='cornflowerblue'>T：</font>（12分大题）

给出文法

求某个句型的规范推导；

画出语法树：证明XX是该文法句型（看终结符）；判断和证明该文法有无二义性

求短语、直接短语、句柄、最左素短语；

！！语法树没有箭头，树的一个结点上只能画一个符号，即保持2型文法（不管运算律）



### 语言设计

表达式的设计：逻辑、关系、算术

<font color='red'>设计算术表达式的时候要考虑运算顺序</font>

*比＋优先，要放在+的下一层，从下往上的时候先被识别

![image-20230315153935818](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230315153935818.png)

语句的设计：说明、执行（复制、控制、复合/语句块）

程序单元的设计

程序的设计

注意区分<>表示内部是非终结符，其他的符号无特殊说明的话是终结符



## 编译概述

翻译：把一种语言转换成完全等价的另一种语言

编译（compile）是把高级语言翻译成低级语言的过程，汇编是把低级语言（如汇编语言）翻译成机器码的过程

解释（interpret）：在执行期，动态将代码逐句解释为机器代码，或是已经预先编译为机器代码的子程序，之后再执行。缺点是重复执行需要重复翻译，花费的时间更多，优点是适合动态语言和交互式环境

java、python都是先编译后解释的语言，java是先编译成字节码（javac），然后在虚拟机上用java解释器执行（java），python是编译成PyCodeObject，对于有重用意义的代码（import模块），会将PyCodeObject写入.pyc文件保存，这样下次就可以根据.pyc直接建立PyCodeObject，不用再次编译

![image-20230320192530733](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230320192530733.png)

![image-20230320192426486](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230320192426486.png)



宿主语言：编写编译程序的语言；源语言、目标语言与宿主语言一般不同

自驻留：编译程序能生成可供宿主机执行的机器代码

交叉编译：生成非宿主机的机器代码

自编译：编译程序是用源语言写的，如C语言编译器



编译步骤（5+2 简答题）

![image-20230313143808729](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230313143808729.png)

注意是先汇编再连接（库程序也经过了编译和汇编）

![image-20230313143823264](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230313143823264.png)



## 词法分析

从左到右逐个扫描字符串，按照词法规则，识别出单词符号作为输出，如果出错则输出错误信息

语言的符号：基本（关键/保留）字、标识符、常数、运算符、界符

输出：（单词类别，单词的属性），属性也可以理解成种别，用于区分是该类中的哪一种，两元都是编码

通常把常数在常数表中的位置编号和标识符在符号表中的位置编号作为其属性值

![image-20230320194912787](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230320194912787.png)

一符一种或者一类一种，将一类作为一种的话就通过属性来区分



词法分析器设计

扫描缓冲区的结构

双指针：起始指针+搜索指针，搜索指针识别到空白符等不属于当前符号的字符就回退一格，输出两个指针之间的内容

双缓冲区

<img src="https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230322085053907.png" alt="image-20230322085053907" style="zoom:50%;" />

![image-20230322145335308](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230322145335308.png)

词法分析的出错处理只能识别数字开头的标识符、字母表以外的非法字符等，对于错把if写成fi这样的错误要结合语法和语义才能分析出来

词法分析器可以作为单独的处理，也可以作为语法分析器的子程序，当语法分析需要下一个新单词时就调用该函数



符号表的管理：一条记录包含名字域和信息域（对应二元式吗？好像不是），由于域的长度不固定，可采用间接表的技术。词法分析阶段当识别到新的名字时就会登入符号表，信息会在后面的阶段完善



## 语法分析

<font color='cornflowerblue'>（T 15‘大题 集合+分析表+控制流程）</font>

输入是终结符组成的串（二元式），输出是正确句子的语法树或报错

不同的字符串可能要用不同的产生式分析，这里可能要选择？

自上而下：从S出发推导到ω

自底向上：从ω出发归约到S	

### 自上而下

若从文法的开始符号S出发, 能为ω构造一个**最左推导**，则ω是一个合法的句子，即ω∈L(G)，否则ω有语法错误。该算法自上而下为w的分析结果建立一棵语法树。

构造最左推导的过程就是选择产生式和匹配符号串的过程



#### 回溯分析法

不确定方法

从开始符起使用产生式，穷举所有的语法树，直到找到匹配的那一棵语法树，不匹配就回溯（类似DFS）

穷举规则：使用待匹配指针指向输入串中的符号，一个一个地尝试当前非终结符的候选产生式（有选择性地尝试含带匹配字符的产生式），匹配到了就指针后移，没匹配上又没终结就回溯

因为待匹配指针是从左往右移动的，所以左递归无法判断何时终止，公共左因子无法选择合适的候选式，而造成回溯

消除回溯：

- 将左递归转换成右递归

  消除直接左递归的方法

  ```BNF
// 左
  S->Sa|b
  // 右
  S->bS'
  S'->aS'|ε 
  //a可以是终结符和非终结符组成的串
  //比如S->S+T，就改成S'->+TS'|ε，！！！别忘了ε
  ```
  

消除推导产生的间接左递归：A1->f(A2); A2->f(A3); ... ;An->f(A1)，一般是这种循环推导产生了间接递归，我们按这个顺序就能推导出直接递归，然后再改写

notice：推导的时候一般会保留根；要把整个链条上的规则都用上才能推导出完整的规则，别漏掉了产生非终结符串的情况，最后检查一下是否等价

- 提取公共左因子

  有左公因子会导致试探策略无法找到改选哪个规则，所以一般提取左公因子，把右边的字符串再写成一个从非终结符到终结符的产生式

- 不管当前的待匹配符是什么，ε都是可能的选项，无法判断应该选哪条规则，除非目前输入串已经扫描结束，只能使用产生ε的规则，所以ε也可能导致回溯

只有自上而下需要消除左递归，自下而上不用



#### 递归下降分析法

我们想构造一个不带回溯的（确定的）自上而下的分析程序，所以先对左递归和公共左因子进行改写（但要注意改写后也不一定能保证无回溯）

对每个非终结符构造函数，在函数中匹配它的产生式，每个候选式写成一个if，如果产生终结符，匹配上了则待匹配指针后移，如果产生非终结符，则调用它的函数，如果一个候选式都匹配不上则报错（所以如果候选式有ε的话是一定不会报错的）



BNF：->, <, >, |

扩充的BNF：{α}：α的任意多次重复，相当于α*；[α]：α可有可无，相当于α|ε；可以画出对应的状态转换图

改写成扩充的BNF，已经相当于做了几步推导，写出了简化形式，所以可以降低递归下降分析树的高度



对于A->B|C这样的产生式，为了判断是选B还是C，就要往前多推导几步，一直推到B和C产生第一个不一样的终结符为止



#### 预测分析法

表驱动

下推栈+预测分析表+控制程序（12分大题：求集合、表，求某个文法的分析过程，分析它是不是LL(1)）

<font color='red'>所有自上而下的方法都要提取公共左因子和消除左递归（**要注意一下有没有间接的，把每个最左的非终结符都代入检查一下**）</font>（改写的时候注意别把根改变了）

1. 控制程序

![image-20230330161427840](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230330161427840.png)

2. 求FIRST和FOLLOW集

FIRST(α)，α是包含N和T的符号串，包含α的所有可能推导的开头终结符及可能的ε（其实也可以直接推，把所有开头的终结符都找出来）

- α->a...|ε，FIRST(α)={a, **ε**}
- α->B...，FIRST(B)-{ε} 加入FIRST(α）（B不可以为空）
- α->$A_1A_2...A_k...A_n$，A1到k-1可以为ε，Ak不空，ε和FIRST(Ak)-{ε}加入FIRST(α）

Notice：只有α能直接产生ε时，对于第三种情况，就是只有A1到An都能为ε时，才将ε加入FIRST(α)，如果是α->Bab...，B->cd|ε，α其实是不会产生ε的，因为后面一定会有ab...，在构造预测分析表时，不能直接产生ε，就不能轮到FOLLOW集

FOLLOW(A)，A的follow集不是S的，包含该文法S的所有句型中紧跟在A后的终结符即可能的#

- #加入FOLLOW(**S 起始文法**)
- S->...Aa...，a加入FOLLOW(**A**)，时刻理解好follow的含义
- S->...AB...，FIRST(B)-{ε}加入FOLLOW(A)，**注意减ε**
- A->...αB，将FOLLOW(A)加入FOLLOW(B)（前加入后）
- A->...BDF..., B后只有非终结符，且都可能为ε，将FOLLOW(A)加入FOLLOW(B)

加入的（子集）可以记下来

一直按这几条规则迭代直到集合不再增大，所以**一定要重复几遍**



3. 构造分析表，所谓预测分析表就是能根据终结符（FIRST集和FOLLOW集）预测产生式（分析表的第一栏中没有空）

![image-20230330154941090](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230330154941090.png)

2）是看α的FIRST，不是看A的，因为可能A->α|β，a只属于α，所以就只将A->α放入M[A,a]，如果没有或，则FIRST(A)=FIRST(α)，只看FIRST(A)即可

3）FOLLOW集对应产生ε的产生式，即自己无法处理就让后面的非终结符来产生，**只看FIRST集中有ε的非终结符的产生式**（是不是放入A->ε就可以了？本质上应该是，但有的可能没有直接写A->ε，而是A->BC，B->ε，C->ε），所以FOLLOW集不一定能全部用上

预测分析表中#对应的一栏可能没有产生式，或者对应A->ε，就是最后是直接遇到#和最后空几个之后遇到#的区别



LL(1)文法 仅利用当前非终结符和**向前查看1个输入符号**（即输入串的带匹配符号）就能唯一决定采取什么动作。

第1个“L”指的是由左向右地处理输入；

第2个“L”指的是它为输入串找出一个最左推导；

![image-20230330161124174](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230330161124174.png)

LL(1)文法可以保证自上而下匹配的唯一性，不是LL(1)文法就会出现分析表中一项可以填两个产生式的情况，有多重入口，不是唯一确定

对于非LL(1)文法，可以设置最近匹配原则来使得入口唯一确定

LL(1)文法的第一条规则可以看作对公共左因子说法的拓展，第二条规则是对非右递归的扩展（A->Aa|ε）



Q&A：

是不是所有递归都能变成右递归？左递归可以，都是线性的，但中间递归和多递归好像不行，中间递归S->aSb，不能改成S->AB，A->aA，B->bB，这样无法保证a和b的个数相同。消除左递归和公共左因子也不意味着就变成了右线性，可能还有直接或间接的中间递归等

改写的意义是什么？消除左递归和公共左因子两种可能产生不确定性的因素，但可能还有别的产生不确定性的因素，比如可能产生两种非终结符（这就需要多往后看几个字符了），所以总得来说，递归形式和LL(1)文法没有确定的关联，右线性文法（即单右递归）也不一定是LL(1)。

有的文法不是LL(1)文法，但可以该改写成等价的LL(1)文法，比如S->aSa|ε，可以改写成S->aaS|ε



### 自下而上

移进-归约分析法

![image-20230410183822135](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230410183822135.png)

即语法树中以每个非终结符为根的子树的叶子结点组成的短语，有几个非终结符（非叶子）就有几个短语

注意：

1. 短语是针对某个句型来说的，在该句型的生成树中，短语只包含叶子结点中的符号
2. 不能由某个非终结符A单独推出的符号串不是短语，S->A+B，S不能单独推出A，A不是短语，A+B才是

直接短语：A推导出β的过程不含多步推导

句柄：最左直接短语

规范归约：找句柄归约，即最左归约，是最右推导的逆过程



#### 算符优先分析法

算符文法（形式有点像四则运算的文法）：不含两个或两个以上直接相连的非终结符，也且不含ε产生式

算符优先文法：如果算符文法G的任何两个终结符之间至多只有一个优先关系（优先关系不是数学关系，不对称，不能传递，也未必存在）

![image-20230410190238979](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230410190238979.png)

素短语：至少含一个终结符，且不包含除它自身之外的更小短语（比如`i1*i2`和i1都是短语，那么i1是素短语，i1*i2不是，因为它包含i1）



控制流程

- 初始压入#
- 读入字符b，a=最顶部的终结符（由于是算符文法，只可能是栈顶或栈顶下一个）
  - a=b=# 结束
  - a<=b b入栈
  - a>b 归约最左素短语（根据优先关系的定义可以证明，最左素短语中的终结符都相等，大于之前和之后的终结符，就是一直往下找，直到出现一个终结符小于上一个终结符），将其出栈，b入栈
  - 空白 出错

算符优先分析法并不属于规范归约，属于结构归约，处于栈顶的最左素短语与对应的产生式**在结构上一致，长度一致，对应的终结符相同，而对应的非终结符可以不同**。比如`F+F*F`可以用`T->T*F|F`归约



优先关系表

构造集合

FIRSTVT(P)：由P产生的第一个终结符，P->a...或P->Qa...，加入a

首先找直接的，然后找P->Q...，后加入前

注意和FIRST区分，FIRST是句子中的第一个终结符，所以对于P->Qa这种一定会继续推Q产生的终结符，而FIRSTVT是句型中的第一个终结符，P->Qa，a就属于FIRSTVT

LASTVT(P)：由P产生的最后一个终结符

先找直接的，然后找P->...Q，后加入前，重复直至不再扩大（每次谁加入谁就用括号标记出来，一旦更改就同时改）

构造表（构造算法要会写，可能会考默写算法？）

![image-20230410194557722](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230410194557722.png)

<font color='red'>a>Xi+1不可以写出Xi+1<a，因为算符的优先是不可逆的</font>，要按规则构造表，a<b和b>a可能同时存在，他们可能来自两个不同的产生式，与归约的先后顺序有关



PS：理解优先关系和控制流程？

归约是自底向上的，所以需要更多步推导出来的优先级更高，被更早归约，所以控制流程中我们也是归约优先级高的

PS：理解从LASTVT和FIRSTVT集合构造表

前两个if对应优先级的第一个定义，第三个if对应第二个定义，第四个if对应第三个定义（记住FIRSTVT、LASTVT都是由非终结符多推了一步出来的，所以都是更优先的、大于的）

？结构规约

PS：算符优先法和四则运算的双栈法、表达式树法

分析规则比较难记，要在理解的基础上结合推理来记忆



#### LR分析法

15分大题，分析过程之前还会考概念，XX项目，活前缀和非终结符的关系等

L是指自左(Left)向右分析输入单词序列；

R是指分析过程都是构造最右(Right)推导的逆过程(**规范归约**)；

括号中的k表示向前展望的输入串符号的个数。

**控制流程**

action表 [状态，输入字符]		goto表 [状态 非终结符]

画双栈归约过程会清楚一些，第一步把a推入符号栈，不用双栈的话就想着状态和符号对应，上托|β|个状态

空栈状态就是s0

![image-20230412165156277](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230412165156277.png)

**求LR表**

1. 文法的拓广

   对于S->A|B的情况接受项目不唯一，不确定什么时候结束，所以在文法G中增加产生式S'→S，从而使S'→S•成为唯一的接受项目（注意，即使S->α没有或，也要加上S'->S，做题规范）

   把或拆开，从0开始给产生式标号

2. 求项目集规范族

活前缀：规范句型（由规范推导推出的句型）中不含句柄之后任何符号的一个前缀

LR是规范归约，所以要识别句柄，活前缀有可能已经含有句柄或者遇到之后的终结符会形成句柄，所以我们可以先识别活前缀（活前缀也可以认为是已进栈的部分）

LR(0)项目：在一个产生式右部添加一个圆点，称为一个LR(0)项目，用以表示**活前缀和句柄的关系**

活前缀与句柄的三种关系 

![image-20230412171044355](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230412171044355.png)

待约的意思是我们期待B入栈，但非终结符不能直接入栈，只能等待其某个候选式的全部符号入栈后归约形成B



识别活前缀的不确定状态转换图

![image-20230412193655006](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230412193655006.png)



消除不确定（ε）->构建LR(0)项目集规范族（有效项目的闭包）

![image-20230412202623734](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230412202623734.png)

![image-20230412200933369](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230412200933369.png)

![image-20230417194742207](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230417194742207.png)

每个状态I是一个LR(0)项目集合，表示现在识别到哪里了，求有效项目的闭包closure(I)，也就是**求所有能产生 形成句柄需要的符号的 产生式**（需要的符号前面加上点就是项目，这样的项目叫有效项目）。如果点后是终结符，那就是形成了移入项目，结束了；如果点在结尾，那就是形成了归约项目，如果点后是非终结符A，那就是形成了待约项目，就要往前多看一步，加入A的产生式A->·β。

goto的意思就是读入·后面的符号，然后发生状态转移，点向后移动，然后再求表示下一状态的闭包，注意识别转移后的状态是不是新状态，有的项目集是从一个产生式（项目）求出来的，只用看第一个就知道了。

可能出现状态转移（goto）到自己的情况，但不会形成死循环，因为移入终结符之后指针后移，下一次匹配的情况改变

<font color='cornflowerblue'>T：求项目集规范族确实很容易错！</font>

- 求闭包的时候可能会漏掉
- 转移的时候可能会漏
- 把重复的状态误认为是新状态，发现一个新状态倒回去一一比对一遍

错了真的很难改，如果不得不改一定要先确定哪些需要改，最好重新写，不要漏改

3. 写表

左半边action[I, a]，右半边goto[I, A]

![image-20230417172553669](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230417172553669.png)                                                                                                                                                                                                                                                   

先找goto(I, a)和goto(I, A)，填入shift和goto，然后再找归约项目

为什么自下而上不用消左递归？自上而下消左递归是因为左递归会导致无法判断何时停止，自下而上归约出开始符的时候自然就停止了，所以不用消



**SLR(1)**

往前看一个待匹配字符，然后结合FOLLOW集，解决移进-归约冲突和归约-归约冲突

注意求FOLLOW集之前不需要消除左递归

构造分析表的时候，第二条规则不再是整行标记成r了，而是对所有b∈FOLLOW(A)，$action[i, b]=r_j$

![image-20230419163609713](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230419163609713.png)





## 实验报告

代码放在报告的最后

考试前一周交报告

语法分析器，当面检查

### 词法分析器

三种报错（要有报错截图）

不匹配，比如Pascal中只有:=出现了：，只有单独的:就不对

非法字符

标识符长度溢出

识别回车是为了报出出错的行数，要详细写出哪一个词出错了

7f 词法分析不会报错

不能直观感受，要根据规则

​    



