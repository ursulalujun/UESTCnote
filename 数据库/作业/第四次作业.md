# 第四次作业

卢晓雅 2020080904026

1

> select * from Movie;

![image-20220415162052442](https://s2.loli.net/2022/04/15/hHJSC2ar13PUme6.png)

2

> select * from Reviewer where name like '%er%';

![image-20220415163015369](https://s2.loli.net/2022/04/15/hmrfX8Yg9IC7ctF.png)

注意字符串用' '括起来

3

> select title from Movie where year<1980;

![image-20220415163434085](https://s2.loli.net/2022/04/15/VZB6otX4H9Jye8N.png)

4 不存在他没评价的电影

> select name from Reviewer where Reviewer.rid in (select rid from Rating R1 where not exists (select * from Movie where not exists(select * from Rating R2 where R2.rid=R1.rid and R2.mid=Movie.mid) ) ) ;

![image-20220416170434894](https://s2.loli.net/2022/04/16/KjU3YhWClVMgwn6.png)

PS: select name from Reviewer where not exists (select * from Rating where Rating.rid=Reviewer.rid and Rating.mid not in (select mid from Movie));不对，Rating.mid not in (select mid from Movie)表示评价了电影名单之外的电影，应该是(select mid from Movie)含于Rating.mid组成的集合

除法，所有一般采用双嵌套，没评价，不存在

Rating(rid,mid)÷Movie(mid)

最外层查询相当于是为了查询name做的连接

5

> select title from Movie where director='Steven Spielberg';

![image-20220415163652702](https://s2.loli.net/2022/04/15/j6Qkge41M7uRSEZ.png)

6

> select distinct year from Movie, Rating where Movie.mid=Rating.mid and stars between 4 and 5 order by year ASC;

![image-20220415164502918](https://s2.loli.net/2022/04/15/AH3L8lVxFTuKhdq.png)

7

> select title from Movie where mid not in (select mid from Rating);

![image-20220415183525243](https://s2.loli.net/2022/04/15/PrGLoWJQy8vqjxp.png)

8

> select name from Rating natural join Reviewer where ratingdate is NULL;

![image-20220415183924696](https://s2.loli.net/2022/04/15/AXoh4wYZEqDVITy.png)

PS: 这里的自然连接可以用子查询和in代替：

`select name from Reviewer where rid in (select Rating.rid from Rating where ratingdate is NULL)`

9

> select name reviewerName,title movieTitle,stars,ratingdate from Movie natural join Rating natural join Reviewer order by name,title,stars;

![image-20220415184823147](https://s2.loli.net/2022/04/15/LZKIdvAnwlSGgC3.png)

字符串类型用order by就是按照字母表的顺序来排序

10

只能是看了两次，不是至少两次！先把看了两次的选出来

> create view Twice as select R2.mid, R2.rid, R2.stars, R2.ratingdate from Rating R2 natural join ( select R1.mid, R1.rid from Movie natural join Reviewer natural join Rating R1 group by (mid,rid) having count(mid,rid)=2);
>
> select name,title from Movie natural join Reviewer natural join (select rid,mid from Twice T1 join Twice T2 using (mid,rid) where T1.ratingdate>T2.ratingdate and T1.stars>T2.stars) ;

![image-20220422154647828](https://s2.loli.net/2022/04/22/RMFudGotl89HYk6.png)

11

> select title,max maxstars from Movie natural join (select max(stars),mid from Rating group by mid) order by title;

![image-20220415190735747](https://s2.loli.net/2022/04/15/BbYMwPQsf2LjdRV.png)

12

> select title,avgStars from Movie natural join (select mid, avg(stars) avgstars from Rating group by mid) order by avgStars DESC,title;

![image-20220416174310794](https://s2.loli.net/2022/04/16/ZfedalvnoRiVk72.png)

PS: select title, AVG(stars) from Rating natural join Movies group by mid;是不对的，可能有重名的情况title就和分组的数量不等，只能select聚集函数表达式和分组使用的字段

13

> select distinct name from Reviewer natural join (select rid from Rating group by rid having count (mid) >=3);

![image-20220416175907105](C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20220416175907105.png)

评价三次及以上，不是评价了三部电影及以上！注意语义，最好的写法是`count(*)>=3`，但用count(mid)也是可以的，因为没有排除重复。这个关系的设置有点奇怪，从语义上应该是rid，mid，date作为主键，但是date有空值，只能是全码当主键，所以count(*)>=3是最准确的

不用having，不对分组使用条件:

> select distinct name from Reviewer natural join (select count(mid) ,rid from Rating group by rid) where count>=3 ;

![image-20220416175400400](https://s2.loli.net/2022/04/16/yJgHlcFqsEjx8i9.png)

注意由于要做自然连接，子查询中还要保留rid

不使用count，用自连接:

> select distinct name from Reviewer where rid in (select R1.rid from Rating R1,Rating R2,Rating R3 where R1.rid=R2.rid and R2.rid=R3.rid and R1.mid<>R2.mid and R2.mid<>R3.mid and R1.mid<>R3.mid) ;

![image-20220422161340052](https://s2.loli.net/2022/04/22/Tr8AYF9MOB6SdqD.png)

这样做出现了不同的结果，因为这样是对三部以上不同的电影做了评价，而不是做了三次以上评价

> select distinct name from Reviewer where rid in (select R1.rid from Rating R1,Rating R2,Rating R3 where R1.rid=R2.rid and R2.rid=R3.rid and R1.ratingDate<>R2.ratingDate and R2.ratingDate<>R3.ratingDate and R1.ratingDate<>R3.ratingDate) ;

在ratingDate有空值，openGauss中空值好像被默认为不符合比较条件了，也无法使用三次ratingDate不同来做判断，好像只能用count

![image-20220422161752259](https://s2.loli.net/2022/04/22/PvqHemcnWxRKaMf.png)

14 

> select distinct name from Movie natural join Rating natural join Reviewer where title='Gone with the wind' ;

![image-20220416171614769](https://s2.loli.net/2022/04/16/aH7X3t8qVxcpmve.png)

15

> select name,title, stars from Movie natural join Rating natural join Reviewer where Reviewer.name=Movie.director;

![image-20220416171925822](https://s2.loli.net/2022/04/16/9xmYFZOKrQRdvHb.png)

16

> select name from Reviewer union (select title from Movie) order by name;

![image-20220421203548127](https://s2.loli.net/2022/04/21/anc2E4kw8jVtyIx.png)

17

> select title from Movie except (select title from Rating natural join Movie natural join Reviewer where name='Chris Jackson ' ) ;

![image-20220421204245646](https://s2.loli.net/2022/04/21/LlKkRrQugSWzUY6.png)

PS: select distinct title from Movie natural join Rating natural join Reviewer where name<>'Chris Jackson';是不对的，“没有”这个语义不能用不等条件，Chris Jackson评价过的电影但是别人也评价了就也会被选进来

用差集，所有电影-他评价过的，openGauss数据库支持except

18

> select distinct Re1.name name1,Re2.name name2 from Reviewer Re1,Reviewer Re2,(select R1.rid rid1,R2.rid rid2 from Rating R1, Rating R2 where R1.mid=R2.mid and R1.rid>R2.rid) where Re1.rid=rid1 and Re2.rid=rid2 order by name1, name2;

![image-20220421210932415](https://s2.loli.net/2022/04/21/m8vtULAVPHW9Oye.png)

PS: 子查询中定义的表名在外层查询中不可以再用，为了不混淆列名可以在子查询中对选出的列进行重命名

去重：自己和自己以及相同pair的一前一后，用rid1>rid2，由于存在一个人评价多部电影，所以可能有重复的项，用distinct

19

> select distinct name,title,stars from Movie natural join Reviewer natural join (select * from Rating where stars=(select min(stars) from Rating) ) ;

![image-20220421211844709](https://s2.loli.net/2022/04/21/K9OIRcUjn2CM14S.png)

也可以select mid from Rating where stars<=ALL(select stars from Rating);

20

> select title,spread from (select max(stars)-min (stars) spread,mid from Rating group by mid) R right join Movie on R.mid=Movie.mid order by spread DESC,title

![image-20220426200839065](https://s2.loli.net/2022/04/26/FKZfOLgurWQTvAm.png)

（openGauss中把NULL当做最大值）

21

> Select r1.avgstars-r2.avgstars diffstars from(select avg(mavg) from Movie natural join (select avg(stars) mavg,mid from Rating group by mid) where year<'1980') r1,(select avg(mavg) from Movie natural join (select avg(stars) mavg,mid from Rating group by mid) where year>'1980') r2;

![image-20220423205833368](https://s2.loli.net/2022/04/23/H2mAIjv5QlOXZES.png)

PS：生成的两个表是不能直接减的，但是可以先把两个只有一行的表做连接，然后用列来做减法得到结果

22

![image-20220421214403298](https://s2.loli.net/2022/04/21/mq4TEdRVtcpWHuD.png)

也可以不使用 COUNT，用自连接

![image-20220422163316994](https://s2.loli.net/2022/04/22/x6PzmLT58qn2dGR.png)

23

> create view avg_stars as select avg(stars) , mid from Rating group by mid;

> select title,havg from Movie natural join (select avg havg,mid from avg_stars where avg>=ALL(select avg from avg_stars) ) ;

![image-20220423210439993](https://s2.loli.net/2022/04/23/rXSELn8oj9vVCfh.png)

PS: from和select语句中都可以定义变量，给列和表起别名，但是由于子查询都是最先执行的，执行顺序不对，重命名很容易出错，所以最好创建视图

24

> select title,lavg from Movie natural join (select avg lavg,mid from  avg_stars where avg<=ALL(select avg from avg_stars) ) ;

![image-20220423210306329](https://s2.loli.net/2022/04/23/AUhwu1GqLDji2zo.png)

注意select的时候列的排列顺序，注意1980是否包括

25

> create view director as select distinct director from Movie where director is not null;
>
> create view max_stars as select distinct M.director,M.title,maxs from Movie M,Rating R, (select max(stars) maxs , director from Rating natural join Movie where director is not null group by director) S where M.mid=R.mid and S.director=M.director and R.stars=S.maxs;
>
> select D.director,title,maxs from director D left join max_stars on D.director=max_stars.director;

![image-20220426203129364](https://s2.loli.net/2022/04/26/QzqeGJFkRgaYvZ9.png)

for each director 每位导演都要保留，用外连接

用max求出每个导演对应的最高得分，还要知道得分最高的是哪一部电影，所以要rating、Movie和director_max连接之后查询

先连接再分组也不行，因为不能select聚集函数和分组字段之外的字段

