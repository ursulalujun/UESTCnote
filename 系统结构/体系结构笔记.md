# 体系结构笔记

## 设计与分析基础

RISC特征：专用的访存指令，定长指令

CISC： Intel和AMD使用的x86，主要针对的OS是Windows和maxOS

RISC： ARM公司的arm，主要针对UNIX，Linux以及IOS、Android等移动设备的操作系统；MIPS 多用在网关和机顶盒上



**计算机分类**

Flynn分类：根据指令流和数据流，SISD改进后可利用指令级并行（即使用多级流水线），单指令流多数据流SIMD，一条指令操作多个数据流，对多个数据流进行一种操作，eg. load(1,2,...,n)，适用于规整的数据，如图像操作。多指令单数据MISD没有太大意义。多处理器就是MIMD（按书上的说法SIMD也是多处理器，不过多处理器只有自己的数据存储器，被统一控制和存储指令）

市场分类：个人移动设备，桌面（台式）计算机，服务器，集群/仓库级，嵌入式。嵌入式与非嵌入式的区别：能否运行第三方软件，嵌入式的已经固化了

服务器的三大特征：可靠性、可扩展性、吞吐量



**定义和设计任务**

传统的计算机系统结构是机器语言程序员所看到的传统机器级所具有的属性。它确定计算机系统的软、硬件界面。

早期的体系结构只强调ISA的设计，当前计算机系统设计涉及多方面技术，从编译器、操作系统到**指令集体系结构**、**组成（逻辑，机器内各事件的排序方式与控制方式）**、**实现（物理、硬件）**技术及功耗、成本、可靠性等设计。

![image-20230601223104761](C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20230601223104761.png)



软件兼容性：同一个软件可以不加修改地运行于系统结构相同的各档机器上，而且运行结果一样，差别只是运行时间不同。

向后兼容：在某一时间生产的机器上运行的目标软件能够直接运行于更晚生产的机器上；向上兼容：在低档机器上运行的目标软件能够直接运行于高档机器上。

系列机：系统结构相同，采用不同的组成和实现，向后兼容

ISA的重要特征：类型；存储器访问；寻址方式；操作数类型和大小；操作类型；控制流指令；编码

ISA分类：寄存器-存储器ISA：80x86；载入-存储ISA：ARM、MIPS，只有load、store指令能访问内存



**可靠性（可信任度）**

广义上包括可靠性、可用性和安全性  

![image-20230316154856881](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230316154856881.png)



评价指标：响应时间（用户视角）、CPU时间（设计者）、吞吐量（管理员）、MIPS（商人）

换用更快的处理器能同时提高响应时间和吞吐量，增加处理器的数量只能提高吞吐量



基准测试程序集

SPEC：实用基准测试程序集

CPI=周期数/指令数=执行时间*频率/指令数

SPEC Ratio：参考计算机上的执行时间/A机上的执行时间=A的性能/参考机的性能，**越大越好**

SM（spec mark）：计算机执行n个基准程序时SPEC Ratio的几何平均值<img src="https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230316155659561.png" alt="image-20230316155659561" style="zoom:50%;" />



**量化原则**

并行性：系统级、指令级、操作级

根据局部性事件

注重常用事件->量化：<font color='cornflowerblue'>Amdahl's定律（T）</font>

Fe 改进比例=可改进部分的时间/总时间

Se 改进加速比=（可改进部分）改进后的性能/原性能=原时间/改进后的时间，**越大越好**

整个系统的加速比 <img src="https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230328144439307.png" alt="image-20230328144439307" style="zoom:50%;" />（计算时注意写成1/x的形式）

当Fe=0时，没有可改进的部分，Sn=1，Se->+∞，则Sn=1/(1-Fe)，改进极限受Fe的制约，提高改进比例*Fe* 或改进加速比*Se*，都可以提高*Sn*，但是*Fe* 对*Sn* 的影响更大。Amdahl定律表明，使用某种快速模式获得的性能改进受限于可使用此种快速执行方式的时间比例。



CPU的性能公式

CPU时间=程序的CPU时钟周期数×时钟周期时间=程序的CPU时钟周期数/时间频率

程序的CPU时钟周期数=CPI*程序的指令数

影响CPU性能的三个因素相互关联，很难在不改变其他两个参数的情况下改变其中一个参数。

CPI与流水线效率、Cache的命中率以及其他存储器效率等有关。

MIPS=主频/CPI



## 指令系统原理和实例

指令集系统结构（ISA）的分类

操作数存储（最根本区别）：堆栈、累加器、通用寄存器（reg-mem和reg-reg）

操作数个数

![image-20230328212231162](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230328212231162.png)

通用寄存器系统结构的分类及特点

![image-20230602152621429](C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20230602152621429.png)

存储器寻址

基本单位：本书讨论按字节，有时也讨论按字

多字节存储，小端模式：低地址存放低位字节；大端模式：低地址存放高位字节

对齐访问：假设一个s字节数据的地址是A，如果A mod s=0，该地址就是对齐的。对齐一方面可简化硬件实现的复杂性，另一方面，一次不对齐访问要通过多次对齐访问拼接完成，对齐访问程序运行较快

最常用寻址方式

- 寄存器寻址

- 立即数寻址

- 位移量寻址（基址寻址）

  ![image-20230602154555252](C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20230602154555252.png)

常用操作数类型：一般通过操作码或者由硬件解释的编码来指定

常用指令操作

常用指令系统编码方式

- 关注代码量大小，选择变长编码。

- 关注程序的执行性能，选择定长编码。

- 折中可以选择混合编码。

MIPS系统结构：64位，RISC，32位定长指令，定长编码，reg-reg，32个64位通用寄存器，32个浮点寄存器



由于机器运行的大多数指令代码是编译器的输出，所以机器性能不仅是其原始速度，还要考虑编译器如何利用系统结构特征（编译器在处理器设计阶段开发，编译后的代码在模拟器上运行，代码用来评估系统结构特征）

编译器还应该做编译优化产生高质量的指令

![image-20230328214752500](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230328214752500.png)



## 流水线技术

流水线是利用执行指令操作之间的**并行性**，实现**多条指令重叠执行**的技术。

时间重叠

锁存器的功能

- 暂存中间数据和控制信号

- 平滑（？同步）

### 分类

按各过程段用时是否相等：均匀和非均匀（怎么可能各段用时完全相等呢？是等待的方式不一样吗）

按处理的数据类型：标量和向量

按规模：操作流水线（算术逻辑部件分段）、指令流水线和宏流水线（由两个以上的处理机串行地对同一数据流进行处理，每个处理机完成一项任务）。

按功能：单功能和多功能

按工作方式：**静态和动态**。这两种都属于多功能，静态是指在同一时间内，多功能流水线中的各段只能按同一种功能的连接方式工作（处理完一种任务才能处理下一种）。所以只有当输入的是一串相同的运算任务时，流水的效率才能得到充分的发挥。

按连接方式：线性（串行连接，每段经过一次）、非线性（有反馈回路）

按控制方式：顺序、乱序，线性流水线可分为：同步、异步



### 时空图与性能

吞吐率 $TP=n/T_k$

各段时间完全相等：$T_k＝kΔt＋(n-1)Δt＝(k＋n-1)Δt$，$n->+∞$ , $TP_{max}->1/Δt$

时间不等：$TP_{max}->1/max(Δt_1,Δt_2,...,Δt_k) $

实际计算中很少用到这个公式，因为还要考虑冒险等因素，Tk需要根据实际情况计算

流水线的效率高：均匀、连续

如何改进瓶颈：细分、重复设置（并行）

![image-20230425095902361](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230425095902361.png)

效率 E 

面积之比 <img src="C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20230409112257409.png" alt="image-20230409112257409" style="zoom:30%;" />

Emax->1

加速比 $S_p=T_s/T_k$

各段时间完全相等时，且不考虑冒险延迟，即流水线的理想CPI为1时，流水线与非流水线（无论是单周期还是多周期）的加速比$S_{max}->k$



<font color='cornflowerblue'>T：分解任务，画流水线，算效率</font>

题目给出的流水线一般是两操作数，分解任务时，两两配对，减少重叠

注意流水线的设计：静态OR动态？串行OR并行



计算Sp时注意，分母是顺序执行的时间，顺序指的是只设计一条指令通道，不做硬件并行（所以k可能和题目中不一样），也不做指令重叠，就是`k*n*Δt`

计算时要考虑冒险耽误的时间，算实际时间，一般不能直接代入公式算

![image-20230409162635661](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230409162635661.png)



多周期本质还是一条指令在单处理器中执行（没有流水线中的那种重叠），只是一条指令的时间有长有短，避免浪费时间，可以分多周期。多周期的实现可以就是把五级流水线的段寄存器去掉，然后每级作为一个周期执行的操作



影响流水线性能的因素：控制延迟、流水线寄存器延迟和时钟偏移、不平衡、冒险、“填充”和“排空”时的吞吐率降低



### 流水线设计

弄清楚每种指令的指令格式，汇编指令和对应的数据通路

sparc指令格式

![image-20230420190419271](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230420190419271.png)

![image-20230420200807626](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230420200807626.png)

注意这个指令的设计和组成原理讲得不太一样，组成原理讲的设计是前两个寄存器一样，读的内容一样，写回的目的寄存器可以选是rs还是rd，这里是目的寄存器都是rd，store指令需要读rd，R型指令读rs2，其他类型指令不需要读第二个寄存器，所以加了MUX选rd还是rs2

所有的控制指令都当做J型处理，判断两个数是否相等然后转移的情况，用$sub+beq/bne$ 构造的loop循环表示，sub之后会存储Z标志，然后beq/bne的操作码和Z标志一起输入到控制器，产生BTAKEN标志，所以**在ID阶段就可以完成跳转**

load和store是I型指令 

load rd imm16(rs1)       R[rd]<--M[imm16+R[rs1]]

store rd imm16(rs1)       R[rd]-->M[imm16+R[rs1]]

store指令的数据通路

d中存的就是编号rd，某个指令的rd会随着指令走，所以各级流水线的d中内容不同 

DSE 偏移量符号扩展器 

五级流水线：IF->ID (Reg/Dec)->Ex->Mem->Wr

![image-20230420192235155](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230420192235155.png)



控制信号

![image-20230420195555001](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230420195555001.png)

addu和subu指的是不用判断是否溢出，应该不用写Z标志吧，其他所有的算术和逻辑运算都要写Z，load/store不写Z

ALUOP1和ALUOP0是用两位的编码表示与、或、加、减四种运算

![image-20230420202618818](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230420202618818.png)



<font color='cornflowerblue'>T流水线分析</font>

把指令写在对应的位置，流水段寄存器中的内容只根据前一条指令来推算，与之前的指令没有任何关系，哪怕是之前阶段产生的结果也会跟着指令走。控制信号也根据当前段的指令推算

PC的变化：IF阶段计算完成后，目标地址就指向IF阶段指令的下一条指令，时钟上升沿，目标地址打入PC寄存器，一般会问第n个周期结束，第n+1个周期刚开始时，就认为IR存放着第n条指令，PC指向n+1条（如果从0开始编号，就是输出n）

所有算术运算和逻辑运算，WZ=1，load/store也涉及计算，但WZ=0，不写Z



### 冒险（hazard）

种类：

- 结构：硬件资源冲突，回写阶段和取数据阶段可能同时使用寄存器、取指令阶段和Mem阶段同时访问主存，没有充分细分功能的部件容易产生结构冒险

- 数据：一条指令依赖前面指令的结果，但该结果还未准备好

- 控制：流水线上执行转移指令时，后面几个周期取到的指令不可用 ，代价最大

解决冒险

普适方法：

- （软件）编译器检测冲突，编译器插入nop指令（写使能=0的指令）

- （软件）编译器检测冲突，编译阶段调整指令顺序

- （硬件）硬件检测信号冲突，增加额外的硬件放“气泡”，让有冒险的指令通过流水线，但是禁止允许任何结果写入寄存器，这样寄存器中的内容不变，就相当于是流水线停滞不动了，因此有冒险的指令“执行”，但是不能“存入”。不同冒险的检测和停顿电路不完全一样，后面细讲

针对结构冒险：

- 增加硬件资源（使用缓冲器）

- 对功能部件进行流水划分（比如周期内分时访问内存）

针对数据冒险：

- 纯硬件检测+停顿

  **检测电路：**

  ID阶段的指令与EXE、MEM阶段的指令可能发生冲突

  Reg运算、立即数运算（load指令等价）、store指令需要考虑冒险，需要检测寄存器ID_rs1, ID_rs2/ID_rd

  转移指令不用检测，立即数运算不用检测rs2，所以

  ID_rs1IsReg=and+andi+or+ori+add+addi+sub+subi+load+store（排除转移指令）

  ID_rs2IsReg=and+or+add+sub （排除立即数运算指令） 

  考虑store指令

  **store指令不回写，在其他指令的前面则没有冲突**，需要排除这种情况，检测EXE和MEM阶段传递的WREG指令（控制是否回写寄存器），即EXE_WREG和MEM_WREG

  rd或rs1用到上一条指令的结果则产生冲突，store和运算指令中的rs1冲突等价，单独加一条检测rd冲突即可

  考虑两个阶段、三种指令、三个寄存器

  相邻指令的冒险会在EXE和MEM阶段都触发暂停信号，停两个周期，之后EXE_WREG=0，MEM_WREG=0，暂停解除

  ```java
  DEPEN＝EXE_A_DEPEN + MEM_A_DEPEN + EXE_B_DEPEN + MEM_B_DEPEN
  
  EXE_A_DEPEN=(ID_rs1= =EXE_rd)(EXE_WREG= =1)(ID_rs1IsReg)
  
  MEM_A_DEPEN=(ID_rs1= =MEM_rd)(MEM_WREG= =1)(ID_rs1IsReg) //这里不能用ID_rd，因为这个周期没结束的时候还没写入ID_rd
  
  EXE_B_DEPEN=(ID_rs2= =EXE_rd)(EXE_WREG= =1)(ID_rs2IsReg)
  	+(ID_rd= =EXE_rd)(EXE_WREG= =1)(store) // 使用MUX选出的rm，可以合并
  
  MEM_B_DEPEN=(ID_rs2= =MEM_rd)(MEM_WREG= =1)(ID_rs2IsReg)
  	+(1D_rd= =MEM_rd)(MEM_WREG= =1)(store)
  ```

  **stall数据通路：**

  输入：EXE_rd, MEM_rd, EXE_WREG, MEM_WREG, rs1, rs2/rd, OP（可译码求出store和

  输出信号取反，作为WPC和WIR，和WZ、WMEM、WREG用与门相连，禁止新的PC值、新的指令、执行过程中产生的结果写入寄存器

  ![image-20230421093224498](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230421093224498.png)

  插stall的话只能在ID级，后面的指令也要stall，停顿时不取新的指令

  ![image-20230423192926806](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230423192926806.png)

- 硬件检测+forwording

  **forwarding电路：**

  取数据的时候bus可以连在MUX前面或后面，送数据的时候连入MUX，给MUX增加更多的选择路，判断是否要选用forwarding送来的数据（注意：一定是在这条指令算出数之后的下一阶段连forwarding）

  ![image-20230411170907140](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230411170907140.png)

  **冒险检测电路：**

  根据前面forwarding的设计可以看出，这里的检测电路需要判断具体是哪种冒险，然后产生MUX四路选择器的选择信号，比之前只要有冒险就停顿的检测电路更细致一些

  分别考虑ALU的rs1，rs2/rd（用MUX选出来的结果，不用单独考虑）与之前指令的rd是否冲突，还是要考虑store指令不写入（WREG），第二个操作数为imm时不用考虑冲突(EXE_rs2IsReg)，如果和前面的两条指令都有冲突，前推最新产生的结果

  可以在EXE级检测，也可以在ID级检测，把检测电路集成到译码器，把产生的ADEPEN和BDEPEN存储到流水段寄存器，？这时就要考虑排除转移指令(EXE_rs1IsReg)

  ALU之前的MUX选择四路，两位信号，画出真值表

  ```
  ADEPEN1=(EXE_rs1==MEM_rd)(MEM_WREG==1)(EXE_rs1IsReg)+(EXE_rs1==WB_rd)(WB_WREG==1)(EXE_rs1IsReg)
  
  ADEPEN0=(EXE_rs1==WB_rd)(WB_WREG==1)(EXE_rs1IsReg)
  
  BDEPEN1=(EXE_rs2==MEM_rd)(MEM_WREG==1)(EXE_rs2IsReg)+ (EXE_rs2==WB_rd)(WB_WREG==1)(EXE_rs2IsReg)
  
  BDEPEN0=EXE_rs2IsReg+(MEM_WREG==1)(EXE_rs2==WB_rd)(WB_WREG==1)(EXE_rs2IsReg)+(EXE_rs2==MEM_rd)(EXE_rs2==WB_rd)(WB_WREG==1)(EXE_rs2IsReg)
  ```

  ![image-20230423200538800](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230423200538800.png)

  A(B)DEPEN=0/1 无冒险，=2相邻指令的冒险，=3相隔一条指令的冒险

  ？课程好像没考虑store指令的rd和前面的指令有冒险，解决store冒险可在DI前面加一个MUX，加一条前推线将WB阶段的MUX输出的内容输入到DI前的MUX，使用独立的冒险检测信号来控制，可以同时解决store指令和前面的ALU指令或sw指令有冲突（rd）的问题

  - 特殊情况：load指令与紧跟的下一条ALU指令有冒险，不能仅用前推解决，硬件检测+停顿一个周期+前推
  
    **stall和前推数据通路**：
  
    前推电路不用改变，增加检测load冒险并停顿的电路即可，和之前stall的电路几乎一样，将检测load冒险的信号取反，作为WPC、WIR、WREG
  
    **load冒险检测**：
  
    只考虑紧跟的指令，所以只用判断ID级和EXE级的相关，EXE_SLD保证前一条指令是load
  
    LOADDEPEN=(ID_rs1= =EXE_rd)(EXE_SLD= =1)(ID_rs1IsReg)+(ID_rs2= =EXE_rd)(EXE_SLD= =1)(ID_rs2IsReg)
  
    所有的检测电路和产生DEPEN的电路都可以集成到控制单元（译码器）中
  
    ![image-20230423204159835](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230423204159835.png)
  
    检测到冒险后WIR=0,WPC=0，ID级的指令产生的所有控制信号全部清零，这样下一周期stall条件就不成立了，暂停解除

针对控制冒险：注意**分别考虑转移地址和转移条件什么时候算出来**，本课程使用的指令格式比较神奇，bne和beq并不计算转移条件，转移条件是根据前面指令写Z的情况来的，通过硬件修改可以将转移地址的计算提前到ID阶段（但要多加一个adder），这样bne、beq、branch后面最多浪费一条指令

- 编译器插入nop

    条件转移，ALU指令+bne/beq，转移指令的ID阶段将Z标志传入译码器算BTAKEN，所以要nop一个周期，等待ALU计算的结果

    ![image-20230420201607112](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230420201607112.png)

- 条件转移预测选中和不选中，预测选中的话需要目标地址比转移结果早算出来才行

    计算转移目标地址需要m个流水段，转移条件形成需要n个流水段(m<n)

    |                | 条件转移发生产生的停顿时钟数 | 条件转移未发生产生的停顿时钟数 |
  | -------------- | ---------------------------- | ------------------------------ |
  | 停顿流水线     | n-1                          | n-1                            |
  | 转移预测未选中 | n-1                          | 0                              |
  | 转移预测选中   | m-1                          | n-1                            |

    

- 硬件stall+废弃（冲刷流水线），stall只能在ID级做，指令还是会进来，stall就是当前指令不产生作用，也不让新的指令进来（写PC、IR），废弃就是当前指令不产生作用，让新的进来覆盖

    ![image-20230423220901815](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230423220901815.png)

    直接转移废弃一条即可，此时IF阶段的指令已经是取跳转后的指令了

    如果是分支跳转，可将BRANCH改成BTAKEN，然后同上图处理

    条件转移需要将bne/beq stall一个周期（称为条件转移硬件暂停），如果预测错误再废弃一条。stall时不需要管写使能信号，因为分支指令本来也不会产生这些

    ![image-20230423222936131](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230423222936131.png)
  
    **EXE_instIsALU不能不要，如果不要的话stall就无法解除了**，只有ALU指令会写Z标志，如果前一条不是ALU指令，就是之前写了，不用停？
  
    ![image-20230424111559743](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230424111559743.png)
  
- 转移延迟，提前计算后，条件转移指令其后的这个周期称为转移延迟槽
  
    如果插入nop，至少要浪费一条指令，那就把一条转移指令之前的无关指令放到转移指令之后，这样这条指令是一定要执行的，不用被覆盖
  
    条件转移最好是从前面的语句中抽取，不能的话也可以预测转移选中或不选中，从目标或者fall-through中抽取，如果预测错误再撤销
    
    ![image-20230411195109384](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230411195109384.png)
    
    loop的延迟槽是循环体的后面一条指令
    
    调换顺序的时候要注意数据冒险
    
    ![image-20230504154950548](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230504154950548.png)
    
    ![image-20230504155017332](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230504155017332.png)
    
    T：调换顺序使最优
    
    首先保证停顿最少，其次保证冒险最少，例题见PPT
    
    注意调整前后都要完整地找一次数据冒险
    
    

<font color='cornflowerblue'>T时序图 </font>

有点像倒置的时空图，标出指令每一阶段的执行内容，如果没有就不标。

**前推线一定在一个周期内，不可以跨周期**。ALU指令的数据冒险就前推到EXE阶段（注意不是ID阶段），store指令的数据冒险前推到MEM阶段。<font color='red'>！！store冒险很特殊，需要检查rd，不要漏掉了</font>

load指令要stall或者nop一个周期之后再前推

**stall发生在ID级**，后面的指令也跟着stall。nop的画法是nop后面跟四个空格子

控制冒险一般会指定用nop或者stall

废除指令的画法是后面都不画了，然后下一周期取下一条指令

![image-20230411172405599](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230411172405599.png)



### 异常和中断

出现异常之后，要废除流水线中异常指令后面的几条指令，PC需要回退，如果后面是转移指令的话就不能单纯地减PC了，所以要用流水线寄存器存储PC

![image-20230603223714998](C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20230603223714998.png)

指令的乱序执行和异常的乱序处理会导致非精确异常

如果异常指令之后有已经完成了的写指令，则机器状态改变，不是精确异常

要实现精确异常，就要**按指令顺序处理异常**

![image-20230604092933964](C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20230604092933964.png)

![image-20230604093046030](C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20230604093046030.png)

也就是说后面的指令出现异常时先暂停，等前面的指令执行完再处理异常，并继续执行，如果前面的指令也 发生异常，就可以先处理前面的

经典5段流水线扩展浮点流水线

增加EXE部件的功能，并进一步流水化

如果整数运算和浮点运算设计成并行的硬件，则不同指令经过的周期数不同，因此会可能产生结构冒险（寄存器堆的写端口冲突）和WAW、RAW、WAR冒险

![image-20230604102312855](C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20230604102312855.png)

![image-20230604094409985](C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20230604094409985.png)

后面的指令更快完成，更早写入

这几种冲突都可以用在ID级增加检测部件，检测到就插入气泡，使流水线操作串行执行



### 指令集引发的复杂问题

记分牌电路，控制什么地方的乱序执行

乱序执行带来的冒险

可以用换名的方式解决，或者使用缓冲区

乱序执行可能出现写后写冒险（WAW）



## 存储器层次

### cache基本原理

**块放置和块识别**

直接映射

全相联

组相连

主存地址划分：标记|cache行号或组号|块内地址

n路组相联，组号数=行号数/n

标记在前，cache行号在后可以保证行号相同的块间隔一定的距离，根据局部性原理，可以减少碰撞

相联的路数增加，碰撞减少，比较标记的时间变长



**写策略**

写直达：数据写cache的同时也写主存，为了消除写停顿，可以设置写缓冲

写回：写cache时不写主存，置换时写回，除了valid位，还需要dirty位



写缺失

按写分配

写的时候按读缺失处理，把要写的块调入cache

不按写分配

直接写内存，不调入cache

通常，写回caches采用写分配；写直达caches采用不按写分配。 

PPT1 p32 例子



数据cache load的四步



分离cache与一体cache

分离是指存放数据和指令的cache分离，分离cache可以避免结构冒险，通常会具有更短的平均访存时间



### cache的性能

![image-20230512101852839](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230512101852839.png)

两个评估指标：

![image-20230512102818551](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230512102818551.png)

注意执行CPI是指正常执行的时间，包括访存时间，但不包括缺失时间

![image-20230512102930762](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230512102930762.png)

分离cache的平均访存时间或缺失率要先分开算，然后再加权平均

指令缺失率=缺失次数/访问指令的次数（千条指令就是访问100次指令）

数据缺失率=缺失次数/访问数据的次数（访问数据的指令比例*指令条数）

指令访存所占的比例=1/(1+x)，x是指令中设计数据访问的指令所占的比例



改善cache的性能（4+5+3+5=17）

1. 减少缺失率：增加块大小，增大 cache 容量，更高相联度，编译优化
2. 减少缺失代价：**多级 caches**，关键字优先和提前重启动（针对只需要块中的一个字的情况），读缺失优于写缺失，合并写缓冲（把要写的内容合并到一起写回，减少写缓冲满导致的停顿），牺牲缓冲（存放几个最近被替换出的块）
3. 通过并行减少缺失代价和缺失率：非阻塞 caches（当等待取数据返回的同时，Cache并不停止，而是可以继续提供指令和数据），硬件预取，编译预取  
4. 减少cache的命中时间：小和简单的 caches，避免地址转换（cache也使用虚拟地址），流水线 cache 访问，路预测（针对组相联，在cache中预留特殊的位，用来预测下一次访问cache可能在组中会用到的路或块），踪迹 caches

看PPT p40-45例题

注意：有36%的指令是数据指令，则指令访存占比`1/(0.74*1+0.36*2)`，数据访存占比`0.36/(0.74*1+0.36*2)`

 

缺失分类

- 强制缺失：第1次访问一个块，它一定不在cache中，因此这一块必须被装入cache -> 利用局部性，增大块大小

- 容量缺失：增大cache容量

- 冲突缺失：提高相联度

cache容量=块大小×组数×相联度，要trade-off



<font color='cornflowerblue'>T：多级cache的性能计算</font>

看PPT p44 例2

![image-20230516202821896](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230516202821896.png)

![image-20230516203002307](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230516203002307.png)

一级cache的全局缺失率=局部缺失率

公式中L指局部，G指全局

![image-20230516203536607](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230516203536607.png)

 

读缺失优先于写缺失，如果要读的数据在写缓冲中，就会造成写后读（RAW）冒险，解决方式就是查看缓冲区是否有冲突，有的话就读缓冲区，或者等写完再读



### 主存

主存性能与两方面相关：延迟，带宽

![image-20230605115459108](C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20230605115459108.png)

由于缺失代价很高，主存块的存放一般使用全相联

主存增加带宽（减少缺失代价）：增加主存宽度，简单交叉存储器

交叉访问时，地址传送和访问可以同时，但发送数据都要通过总线，不能同时，以n交叉传送，缺失代价为T(发送地址)+T(访问)+T(发送单字)*字数

### 虚存

在操作系统中使用虚拟内存，每个进程会认为使用一块大的连续的内存。事实上，每个进程的内存散布在物理内存的不同区域。或者可能被调出到备份存储中(一般在硬盘)。当一个进程请求自己的内存，操作系统负责把程序生成的虚拟地址，映射到实际存储的物理内存上。操作系统在分页表中存储虚拟地址到物理地址的映射。每个映射被称为分页表项。

几乎所有操作系统都替换最近最少使用（LRU-least-recently used）的块

写策略一般采用写回方式，设置脏位

TLB

TLB也可以使用三种相联策略，将虚拟页号划分成标记和索引



### 虚存与cache结合

这时一级cache一般存放页内的块，下图为一级cache容量恰好为一页的情况

注意，此时两级cache还是使用物理地址来定位的，每个进程都有自己的页表，虚拟地址可以重复，因此cache和主存都必须使用物理地址才不会出现冲突

一级cache，将页内地址划分成索引和块内地址，物理页号作为tag

一级cache的查询与TLB查询同时进行，TLB查到物理页号后，与cache相应行的tag进行比较，确定一级是否命中，如果没命中，再划分物理地址查询二级cache

![image-20230605161323738](C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20230605161323738.png)

<font color='cornflowerblue'>T：求位数划分</font>

如果是组相联或者直接映射，就需要知道容量，计算组数或行数，计算组索引或行索引位数，剩下的是tag；如果是全相联，总位数-块内偏移就是tag，不用给出容量

![image-20230516205933852](https://raw.githubusercontent.com/ursulalujun/picture/main/images/image-20230516205933852.png)

## 期中考试

第一章 计算题

第三章 

拆分+时空图+计算

时序图+前推线

流水线分析



## 期末考点

第一项重点，X86和MIPS，两种寄存器



时空图期末不考

控制冒险：前后插nop解决的问题，stall，预测，延迟槽

精确与非精确

浮点流水线在EXE阶段延迟较长，需要进一步细分



性能计算：平均访存时间，CPU时间

虚存不用太细，主要看TLB的结构和作用、cache与虚存的结合



选择题、计算题、分析题*2、综合计算题

