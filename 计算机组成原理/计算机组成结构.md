# 计算机组成结构

## 第一章

### 计算机结构发展

**冯诺依曼计算机：**

1. 运算器、控制器、存储器、输入设备和输出设备
2. 采用“存储程序”的方式工作
3. 指令和数据采用二进制存储，形式上没有不同，但是存储位置（存储器IR，MDR）不同，地址不同，得以区分
4. 指令由操作码和地址码组成
5. 数据存储，数据传输，数据处理

第一代采用电子管元件，第二代采用晶体管元件，磁芯作内存，磁鼓、磁带作外存等。第三代采用中小规模集成电路，半导体存储器作内存，出现了微程序控制，Cache，虚拟存储器，流水线等技术。IBM公司提出了“兼容机”的概念，DEC公司提出了总线结构。第四代采用大规模/超大规模集成电路，出现了微处理器，出现了共享存储器，分布式存储器及大规模并行处理系统等技术

![image-20220224104955510](https://s2.loli.net/2022/06/26/sTda5tVLmkyXbEr.png)

存储设备包括内存memory（包括主存和缓存cache）和外存storage（包括磁盘和固态硬盘）

系统软件包括操作系统，语言处理系统、数据库

IO设备也称外部设备，包括网卡、显卡、键盘、接口等



### 程序的执行过程

1. 程序的解释和编译：用语言处理器翻译成机器语言目标程序，然后把目标程序的指令和数据存入内存，每条指令和每个数据都有地址，指令按序存放，指令由操作码和地址码组成

   解释型语言是一条条解释成机器语言，直接执行

   编译型语言是编译生成一个可执行的文件，下一次无需重新编译，直接执行这个文件即可，效率较高

   `hello.s`是汇编语言程序文件，`hello.o`是二进制文件

   ![image-20220226161018039](https://s2.loli.net/2022/06/26/SqdJR9Eb7VpPGT5.png)

2. 指令执行过程：根据PC取指令->指令译码->取操作数->运算->回写结果->修改PC的值，继续执行下一条指令

![image-20220224104013972](https://s2.loli.net/2022/06/26/uGOjf1n792iVMgK.png)

### 计算机性能评价

响应时间和吞吐量

CPU时间=CPU用户时间+CPU系统时间

时钟周期数，时钟频率

CPI： 一条指令执行所需的平均时钟周期数

CPI常常是一类指令或者一个程序的加权平均值

CPU执行时间=CPI×程序总指令条数×时钟周期，这三个因素相互制约，必须全面考虑，一般不能单独改变一个

**定点**指令运行速度的单位MIPS million instructions per second

浮点 MFLOPS，基于操作次数而不是指令数来衡量的

峰值MIPS，使平均CPI最小的一组指令的MIPS

MIPS是不一定可靠的

综合评价

1. 加权平均
2. 用基准归一化 参考机上执行的时间/被机器执行的时间，越大越好

## 第二章

### 进位计数制度

基数和权值

10->d 整数除d取余，从下往上写（也可以直接找最近的2^n^-1再加减），小数是乘d取整，从上往下写

d->10 按权相加

2^n^ <->2进制，分组转换，二进制分成每组n个数，从小数点开始往两边分，小数点后的末尾添加0，小数点前开头添0

### 定点表示

**编码** 带符号数的最高位是符号位

正数0：原码=反码(one's complement)=补码(two's complement)

负数1：反码：符号位不变，其他取反，补码=反码+1（末尾，小数的话就是在最后）

<font color='red'>补码的原理是模系统，由于机器内的位数有限</font>，进位自动消失，和模系统是等价的，-A相当于+模-A，所以$X_t$为负数是，<font color='red'>定义式：</font>$[X_t]_补=M-|X_t|=M+X_t(mod)M$

负数的补码+原码=-2^n^     [[X]补]补=[X]原

反码+1只是简化计算，且对-2^n^不适用

<font color='red'>补码比原码和反码多表示1个负值</font>，-2^n^ ~ (2^n^-1)，原码的-0在补码中就是-2^n^

位数不同，模就不同，变成的补码不同，在机器内部，位数固定

补码只有加法，只要不出现一个进位一个不进的错误，补码同时进位不处理，mod M后是正常的

移码：+bias，一般是编码位数为n（<font color='red'>注意包括数值和符号位一起n位</font>）时，+2^n-1^，这样的话<font color='red'>同一个真值的移码和补码仅符号位不同</font>，0的移码是唯一的

可以去掉符号位，比较容易，便于电路实现

**扩展操作**

带符号整数：符号扩展
无符号数：0扩展

<font color='red'>直接变二进制表示无符号数，补码表示带符号数</font>

![image-20220305165012841](https://s2.loli.net/2022/03/05/v5S1omhZieknKPt.png)

### 浮点表示

规格化数的标志是尾数部分的最高位具有非零数字（±0.1......)这里有点绕，因为和IEEE的规定不一样

左规，左移尾数使达到规格化，阶数减小，右规，右移尾数，阶数增大

![image-20220303103143592](https://s2.loli.net/2022/06/26/y3vxgVrNZM9LQY6.png)

<font color='skyblue'>T：Decimal to FP</font>，1. 写出二进制  2.变成小数点前是1 （科学计数法） 3.求阶码+127   4.符号位+阶码+尾数（原码，隐藏1），注意四位一写，三部分之间分开

<font color='skyblue'>T：FP to Decimal</font>，1.求阶码-127  2.写出科学计数法形式（要注意小数点前面一定是1）  3.阶码拿进去变成二进制  4.变十进制

![image-20220301172658665](https://s2.loli.net/2022/06/26/6iTkcb523YfrKPo.png)

非规格化数：隐藏位为0，阶数是-126或-1022，补充了规格化数从   -2^-126^~2^-126^的空缺

范围：浮点数的溢出问题，正负、上下溢

不在四个溢出区内，但因为精度不够（间隔不够小）不能表示：float的有效数值位是24位，即能正确表示的10进制位数是7位，所以当用户输入的浮点数超过7位数字时，机器无法表示就会用就近的能表示的数进行代替



**<font color='skyblue'>T：C语言的类型转换</font>**

1. 

- 定点类型之间的转换（仅长度改变，有无符号不变）

长变短，一般是高位截断，保留**低位**的两个字节

短变长，注意扩展，无符号数是用0扩展，有符号数的原码用0扩展，就是最高位和有效位之间都用0填充，有符号数的补码用符号扩展，只有这样才能符合负数的原码变反+1=补码的规则

- 有符号和无符号之间的转换（定点，长度不变）

主要是编码的规则会改变，无符号是直接的二进制，有符号定点是补码

按原类型转换成机器数->按**转换后的类型的编码规则**翻译成真值(<font color='red'>！！易错</font>)，转成`int`了就要翻译补码

有时也会把这两种结合起来考，那就要在中间加一步长度的变换

运算表达式中同时出现有符号和无符号数，**有符号就会被强制转换成无符号**后再运算

- 定点和浮点的转换

定点和浮点之间的转换不是单纯的换一种方式翻译就可以了，存储的位置也是会改变的，相当于是翻译成真值，然后再转换

如果32位都写满了，转化float浮点数时，尾数只有23位，那就会丢失一部分，再转化成整数就会改变，但是如果转化成double52>32，不会丢失

float、double转换成int，都可能会丢失，一般是**从小数点后面截断**

浮点数的变负数就是变符号位，不会丢失，但是由于补码多表示一个负数，int取反后可能会改变



使用不同于变量类型的输出方式，本质上也就是类型转换：

%u 十进制无符号 %d 十进制带符号整数，用%u输出int，先写出机器值，即补码，然后把它当作无符号数来解释，就是整个二进制变十进制，用%d输出unsigned 先变二进制，然后当作补码转换成十进制（p37）



由于对阶、溢出问题，加法结合律可能会不成立

![image-20220303103822929](https://s2.loli.net/2022/06/26/GCXUhBSLRentKZ4.png)

汉字字符有输入码、内码和字模码，汉字内码大多占两个字节

### 数据宽度

bit：计算机中处理、存储、传输信息的最小单位

byte：编址的最小单位

字：表示被处理信息的单位，用来度量各种数据类型的宽度

字长：进行数据运算、存储、传送的宽度，三者在一个部件内一般要一致，反映了计算机的信息处理能力，机器字长指的是CPU内部用于整数运算的数据通路的宽度，指令字长，存储字长

字长和字的长度可以不一样

文件大小、流量一般用1024进制，B byte

带宽一般用1000进制，b bit

### 数据的存放

小端：MSB存放在高地址中

大端：MSB存放在低地址中（写的时候就是从头到尾、从上到下顺着的）

数的地址都是最低字节的地址

存放方式一致才能直接进行数据传输

对齐：按字地址、半字地址、字节地址访问，就有相应的对齐方式，比如按字对齐，每个变量放在尽量少的字内

不对齐虽节省了空间，但增加了访存次数，因为读取每次读一个存储字

![image-20220305170644039](https://s2.loli.net/2022/03/05/ErujnFXQy3aJomv.png)

### 数据的验错

层架校验位，增大码距（增加冗余）就能提高纠错能力

两个码字中具有**不同代码的位的个数**叫这两个码字间的“距离”
码制中各码字间**最小距离**为“码距”，它就是这个码制的距离。

![image-20220305171104024](https://s2.loli.net/2022/03/05/UuTgoIVx571e9fQ.png)

**奇偶校验码**

加上奇校验码之后有奇数个1

码距是2，有1位不同，校验位就也不同

只能检验有没有错，不能判断位置，也不能改错

**海明校验码**

校验码个数：2^x^ ≥　n+x+1, 设数据有n位，校验码有x位。

位置：2的整数幂

**循环冗余校验码**



## 第三章

### 高级语言中的运算

算术运算、按位运算、逻辑运算、移位运算、位扩展和截断运算

左移k位等价于 *2^k^，注意是否溢出

![image-20220308191613817](https://s2.loli.net/2022/03/08/ALa89CqhJfw5FNv.png)

### 指令集中的运算

MIPS指令集：定点算术运算指令集

注意有符号和无符号的转换成真值的方式不一样，比大小的时候要尤其注意类型

MIPS有32个通用寄存器（`$0-$31`），寄存器不是内存，没有地址，只有0-31的编号，指令需要规定存放操作数的寄存器和记录结果的寄存器

MIPS提高32个32位单精度浮点数寄存器：`$f0, $f1, ……, $f31`，连续两个寄存器（一偶一奇）存放一个双精度浮点数

定点数据传送指令

![image-20220308191830058](https://s2.loli.net/2022/03/08/bzVtaJT2KRDHg6E.png)

意思是`$`2里的值+100得到一个值，把这个值作为一个地址到内存里去找，把内存里存放的值取出来放到寄存器$1里面

### 运算部件

#### 加法器（串行和并行）

ALU可进行基本的加/减算术运算和逻辑运算。其核心部件是加法器。

![image-20220308192417375](https://s2.loli.net/2022/03/08/PDEWwJGApKObz3r.png)

串行加法器的延迟太严重，2(n-1)+3（前n-1位只用算出进位位就可以了，最后1位算sum）。现代计算机采用一种先行进位方式，并行计算进位，实质上就是把表达式代进去，然后同时算，这种并行运算加法器称为CLA加法器。

假定与/或门延迟为1ty，异或门3ty

并行/先行进位，使进位位的产生相互独立（做法就是代入），可并行产生 

![image-20220308114348011](https://s2.loli.net/2022/03/08/In1KaXcmZUlRExf.png)

但是又不想把CLA做得太复杂，所以一般是8位分一组，组内并行，组间串行，单级先行进位（PCLA）

![image-20220308114800772](https://s2.loli.net/2022/03/08/UGwHyTNrJ7PEcZg.png)

计算所有的Pi, Gi是可以同时进行的，所以只用在算最低的8位的时候加上计算他们的时间就可以了，所以第一个是3ty，只有最后要算sum，所以最后一个是（2+3）ty

最后还可以组内和组间都并行，多级先行进位（BCLA）

![image-20220605151625392](https://s2.loli.net/2022/06/05/xZ3dVyut8DUSG5W.png)

<font color='cornflowerblue'>PS</font>：以下这个加减法部件有自己的一套运算流程，它只管按照这套流程来产生结果和标志，并不知道自己在算的是什么（是带符号数还是无符号数？有没有溢出？），是人利用结果和标志来制定了一些规则、做了一些判断，最终使得能借助加减法部件完成补码、原码、移码的加减法运算

#### 带标志的加减法器

![image-20220310103925705](https://s2.loli.net/2022/03/10/BpLiucJ7kf3wPq1.png)

条件标志：会被存到专门的寄存器里，在分支指令（条件转移指令）中被用作是否转移执行的条件，溢出标志$OF=Cn⊕ C_{n-1}$​，符号标志$SF=F_{n-1}$​，零标志ZF=计算结果的所有位F取或非，判断计算结果是否为0，为0，ZF=1，进/借位标志$CF=Cin⊕Cout$

**逻辑运算部件**

部分积（乘积P）初始为0，相加时最高位的进位保留到C中，就是简单的与或非、异或门



### 运算

#### 定点加法

##### 带符号数

- 补码

运算逻辑：带符号数用补码表示，**符号参与运算，所以只区分加减法，不区分正负**，以下的X和Y可正可负，代入公式等同处理

$[X+Y]_补=[X]_补+[Y]_补$

$[X-Y]_补=[X]_补+[-Y]_补=[X]_补+[Y]_补取反+1$ （这里的取反包括符号位）

利用加减法部件：当Sub为1时，做减法；当Sub为0时，做加法

OF：判断补码相加是否溢出，最高位和符号位产生的进位不同则OF=1溢出，对于原码运算OF没有意义（判断补码运算是否溢出还有一种方式：两个加数（输入加法器的A和B'）的符号位相同，且与和的符号位不同）

SF：判断补码的符号位，就是输出$F_{n-1}$

- 原码（浮点数的尾部运算）

运算逻辑：原码表示，是要考虑符号位的

1. 用符号位和操作符判断求和还是求差，然后拿掉符号位（相当于是先考虑符号，然后绝对值求和差，最后再判断符号）

2. 数值求和或求差

   求和：直接相加

   求差：第一个数的数值位+第二个数的数值位取反+1（原理：去掉了符号位之后就只剩下数值，数值可以都看做是正数，正数的原码和补码一样，所以可以看作$[X]_补-[Y]_补=[X]_补+[Y]_补取反+1=[X-Y]_补$ 

   a)最高位有进位（cout=1，CF=0），说明够减，结果为正，数值位不变

   b)<font color='green'>没有进位(CF=1)</font>，说明有借位不够减，结果为负，现在的数值是补码形式，<font color='green'>需要求补还原回去</font>

3. 判断符号，数值求和的话符号取第一个数（被XX）的符号，数值求差的话，a）取第一个数的符号，b）取第一个数的符号取反

溢出判断，求差不会溢出，求和的时候判断是否溢出



- 移码

运算逻辑：符号位和数值位一起处理，移码的和、差等于和、差的补码，最后再将符号位取反就把补码变成了移码（这其实不是真正的移码运算，移码运算是要算和、差的移码）

浮点数的阶码还要-1，不适用

$[X]_移+[Y]_移=2^{(n-1)}+X+2^{(n-1)}+Y=2^n+X+Y$

$=2^n+X+Y(mod2^n)=[X+Y]_补=[X]_{补}+[Y]_{补}$

$[X]_移-[Y]_移=[X-Y]_补$



##### 无符号数

纯二进制，没有符号，可以类比原码去掉符号位之后的操作

（无符号数是直接没有符号，浮点数的尾部的运算是有符号，但是符号和数值分开处理，相当于是原码的运算）

CF=1表示有借位或进位，加法cout=1，CF=1，说明实际结果可能大于能表示的最大无符号数（进位），减法cout=0，CF=1，说明被减数小于减数（借位）

无符号数一般不考虑溢出，因为地址本来就是可以循环使用，做模运算的，对于无符号数，SF和OF没有意义

可以看出，这些无符号数和有符号的三种码的运算都是在补码运算的基础上做改动就可以完成的，所以只要修改上述代表值的加减法器就可以了

<font color='cornflowerblue'>做减法以比较大小</font>
Unsigned: CF=0 & ZF=0时，大于 ；Signed： OF=SF & ZF=0时，大于；
两种：ZF=1 ,等于



#### 定点乘法

<font color='cornflowerblue'>无符号数的乘法</font>

不用考虑小数点的位置，约定好最终乘积中小数点的位置就可以了

手工乘法是把分步乘积逐渐左移，机器把上一步的结果逐渐右移，效果是等价的，机器采用右移的好处是可以逐渐把被乘数算过的位移出，合理利用乘数寄存器Y存放低n位的结果，还可以移入进位。手工乘法的进位会保留下来，留到结果中或者和下一位的乘数相加，在机器中就是用一个进位位记录，然后下一次右移入结果中

![image-20220315105252307](https://s2.loli.net/2022/03/15/2LXIkJms36MPRWp.png)

和yi(0,1)的乘法就是1的时候+X，0的时候不加，所以就是判断->加法->右移，Y有几位就要右移几次

![image-20220315111401510](https://s2.loli.net/2022/03/15/QfVmF5AMDtyZv3O.png)

相加时最高位的进位保留到C中，右移时进位C、部分积P和剩余乘数R一起联合逻辑右移。

其实最后2n位都保存着正确结果，只取某几位，可能发生溢出

二位乘法器

每次取Y的两位来计算，速度可以比一位乘法器快一倍

快速乘法器

为了不用时钟控制，提高速度

类似手算乘法，先并行和被乘数的每一位相乘（与门），然后错位相加，是用空间换时间

<font color='cornflowerblue'>有符号数原码（浮点尾数）运算</font>

符号与数值分开处理：积符由异或得到，数值用无符号乘法运算

MIPS中有一对32位寄存器Hi 与 Lo ，乘法时存放乘积的高32位和低32位，除法时Hi存放余数，Lo存放商



#### 浮点运算

**加减法**

1. 写出两个数的浮点形式

2. 求阶差：这里不是要真的去算差的移码 ，能判断差的正负就行，$[X-Y]_补=[X]_移+[Y]_移取反+1$​，求δE的真值，<font color='green'>小的向大的对阶</font>，最后的阶取大的（方便后面的规格化）

3. 对阶：如果δE>0，就操作y，否则操作x，写出Ey, Ex, My, Mx（尾数的表示带上符号位，<font color='red'>注意还原隐藏的1</font>，保留两位附加位）

4. 尾数加减，注意这里是原码的加减，先判断求差还是求和，算完数值后确定符号

5. 规格化，手算的时候是移动小数点，在寄存器里面移动的是数值，左规和右规就是把数值左移和右移，<font color='red'>右移时注意隐藏的1</font>

   ![image-20220317104812681](https://s2.loli.net/2022/03/17/vJTSCFIHlrP3zZu.png)

6. 附加位的舍入

7. 判断是否溢出：浮点数的溢出不是通过尾数来判断的，尾数进位溢出可以通过右规来纠正，<font color='green'>浮点数的溢出主要看阶码</font>，右规：**右规**前先判断阶码是否**全1**，若是，则直接是上溢出了，否则阶码+1后再看是否全1；**左规**前先判断是否**全0**，不是的话-1再判断（就是注意不要跳过了全1全0的情况）

若运算结果是0，则需要将阶码也置0。

左规，阶码-1，在机器中就是+255，+1111 1111

最高有效位有进位时，记录进位，然后尾数右移，把进位移入，阶数+1，然后移出的尾数最低位用附加位保留，对阶时向右移出的尾数也可以放在附加位里，最后将其进行舍入，避免运算过程中的精度损失。

尾数加法器最多需要1+23+3位

对阶的时候如果阶数相差超过24就会大数吃小数，结果等于大数

**乘法**

只有求阶数和尾数相乘两步和加减法不一样，尾数相乘就用原码乘法的规则，符号位异或判断，求阶数：注意和标准移码区分

![image-20220317204240638](https://s2.loli.net/2022/03/17/W41gbEnQ9S2KhYr.png)

判断溢出：$[E_b]_移$全1或全0，或者计算过程中最高位改变了



计算公式总结：

补码的原理mod 2^n^，移码 +2^n^或者+2^n^-1

$[X]_补=[X]_原$变反+1 （对-2^n^ 不成立）  

$[[X]_补]_补 =[X]_原$           

$[X+Y]_补$

$[X-Y]_补$

$[X]_移+[Y]_移$

$[X]_移-[Y]_移$               

补码和移码只相差符号位（ +2^n^-1时）                                                                                                                                                                                                                                                                                                                                                                                                              



## 第四章

指令集体系结构（ISA）是软件和硬件的交界接口，设计要便于硬件实现的同时便于写编译器

按照“存储程序”的方式，指令存储在主存中，由一个操作码和几个地址码组成，地址码要能表示（或隐含）源操作数或其地址，结果的地址（可以是主存地址、寄存器编号或I/O端口），下一条指令的地址（主存中）

地址码的个数从0到3，三地址和二地址都是双目运算，一地址可以单目或双目运算（另一个操作数和结果可以默认存放在累加器中），零地址可能是本身就无操作数，或者对于栈型指令，操作数默认在栈顶，不需要地址

### 设计原则

指令要短而规整

要有足够的操作码位数，因为向后兼容会使操作类型不断增加

指令长度应该是字节的整数倍，因为按字节编址，这样比较方便存取地址

### 指令设计的基本问题

操作数类型和存储方式

操作类型

地址码的编码

问题：以上各种寻址方式下，操作数在寄存器中还是在存储器中？有没有可能在磁盘中？什么情况下，所取数据在磁盘中？虚拟地址体系，操作数可能在磁盘中，即发生缺页，但也要调入内存中才能访问

- 地址码的个数

- 寻址方式：立即（地址码存的就是操作数，立即数） / 直接（存的是操作数的有效地址） / 间接（存的是间接地址，间接->有效->数） / 寄存器（存的是寄存器编号，该编号的寄存器中存着操作数） / 寄存器间接（该编号的寄存器中存的是有效地址） / 偏移（相对、变址、基址） / 堆栈

  ![image-20220325154050186](https://s2.loli.net/2022/03/25/RN6Gi8ysAHfY5CB.png)

  有效地址是指操作数所在存储单元的地址，（）就是寻址取值运算

  可以设置或不设置专门的寻址方式位

  MIPS中的load和store就是寄存器间接寻址[$X]，从寄存器中取出数据作为地址，或者把表示地址的数据存入寄存器

  ![image-20220322114535129](https://s2.loli.net/2022/03/22/6LUJuMaDfrBP4Ry.png)
  
  load `$`2,  20(`$`3)  在20的基础上+$3中存放的数据，就相当一种变址寻址
  
  数组的寻址可以看作变址寻址，首址就是数组的首地址，变址器I每次自动加/减数组**元素的长度x**，确保跳到下一个元素
  
  基址，基准地址存在基址器（R）中，偏移量用A给出，变址，偏移量由变址器R给出，基准地址由A给出
  
  ![image-20220325120249136](https://s2.loli.net/2022/03/25/X8yKwb9jkZFWOdJ.png)
  
  <font color='cornflowerblue'>T：寻址方式</font>
  
  ![image-20220325115637213](https://s2.loli.net/2022/03/25/kpAYtCmh5OKJEeU.png)
  
  按字节编址，每条指令是两个字节，所以指向下一条指令PC=指令地址+2，单元就是编址的单元，也就是D的单位是字节
  
  <font color='red'>notice！！</font>  
  
  1. 只有确定了<font color='red'>寻址方式、是按字还是字节编址、位移量D是指指令条数还是单元数</font>，才能确定目标地址范围（目标地址范围不等于位移量D的表示范围！），<font color='red'>最后都换算成编址单元数来算</font>
  
  2. 通常计算有效地址时（题目说总是在取指令同时对PC增量），PC已指向下条指令! PC=指令地址+指令长度（以编址单位计算）
  
  隐含地址：累加器、栈

操作码的编码方式：定长（对性能要求高），扩展（代码长度要尽量短）

<font color='cornflowerblue'>T：</font>扩展编码就是操作码<font color='cornflowerblue'>按从短到长扩展</font>，由于读的时候并不知道操作码有几位所以各类指令操作码必须<font color='cornflowerblue'>互斥</font>，短的用过的操作码，长的不能再用，操作码长度=指令长度-地址码数*地址码长度，地址越多操作码就越短

求条数，分成几段来求，现在总共能用多少位，每段各有多少种组合，然后乘起来

![image-20220325120826483](https://s2.loli.net/2022/03/25/pcXmFkv3eI6ORTV.png)

标志信息（条件码或状态位）的生成和使用：NF（SF） /  VF（OF） /  CF  /  ZF

对于带符号数和无符号数运算，标志生成方式没有不同，因为加法电路并不知道你输入的是什么数，只是可用的标志和标志表示的信息可以认为规定，会有不同，无符号只用CF、ZF，有符号用SF、OF、ZF



### 指令风格

- 按操作数位置来分：

累加器型（一地址指令）、栈型（零地址）、通用寄存器型（操作数可分为立即数I，来自通用寄存器R，来自存储器S）、Load/Store型（也是使用通用寄存器来存放运算数据，但只有Load和Store指令能访问存储器，运算指令不能访问

- 复杂指令和精简指令（采用Load/Store型）

CISC使用多周期指令，微程序控制，难以编译优化；RISC采用load/store指令设计风格，流水线，大量通用寄存器，硬连线控制器，优化的编译系统。

CISC中20%的简单指令占程序代码的80%以上，微程序控制器中，占指令总数20%的最复杂指令占用了存储器80%的容量

### 程序的机器级表示（MIPS）

#### MIPS的数据存储

MIPS的字长32位，按字节编址，程序计数器PC指向下一条指令的地址，只能通过load/store指令访问存储数据，操作数长32bits，寄存器存储也是32bits，偏移量是16bits的带符号整数，可访问的地址空间是4GB

通用寄存器、指令寄存器、浮点寄存器、商乘寄存器

$zero存放0，`$ra`函数的返回地址

#### MIPS指令

**R型指令**

![image-20220329221315091](https://s2.loli.net/2022/03/29/6EWcpUeInNaT9HX.png)

寄存器寻址，怎么区分直接和间接？

OP=000000，功能由func决定，可表示：算术运算（加减），逻辑运算（与、或、异或），位移，跳转

MIPS没有专门的赋值指令，$zero中一般始终存储0，`addi r2,r0,50`来把`$2`赋值为50

**I型**

![image-20220329221902382](https://s2.loli.net/2022/03/29/fBjHTK2a9dCyP3m.png)

可以表示：立即数的加、逻辑运算、取字存字、相等/不等（条件）转移，设置高位

16位的立即数需要拓展，相加看作带符号，做符号拓展，逻辑运算符号不重要，统一用0拓展，偏移寻址的时候<font color='cornflowerblue'>imm作为偏移量</font>，也要用符号拓展，有加有减

<font color='red'>！！！</font>偏移寻址时imm表示的数以字节为单位，转移beq/bne时以指令为单位，所以要乘4，<<2（汇编语言中涉及偏移都是以字节为单位）

![image-20220330173112630](https://s2.loli.net/2022/03/30/mBGejCo3yfQp2vV.png)

立即寻址，寄存器寻址，存取可以看作基址或变址寻址，转移是相对寻址

**J型**

可表示：无条件跳转和调用

调用和转移的区别，调用指令要记录跳转之前的地址，执行完后还要返回来

![image-20220329110501790](https://s2.loli.net/2022/03/29/YlDzsxwET9qvo4C.png)

伪直接寻址，需要进行转换，把address向左移两位，低位补0，$最终地址=PC_{31～28}||addr.||00$，位数：4+26+2=32

MIPS没有专门的寻址字段，由指令格式来确定，OP能体现指令格式



<font color='cornflowerblue'>T设计指令系统：</font>

第四章 T7

1.寄存器个数--编号长度，操作种类2^k^--操作码占k位，放在最高位

寻址有两种方式：1）没有具体的寻址方式说明，直接对指令类型进行编码  2）指明每个操作数的寻址方式。寻址方式的种数--寻址方式位长度，注意没必要区分两个操作数，毫无意义地增加指令的复杂度，RS和SR等同处理，每个操作数4种寻址方式，一共4+C4 2=10，4位以上的寻址方式位

2.立即数和寄存器直接不用访问存储器，寄存器间接和变址都是访问一次存储器，变址是基地址+存储器内存放的数字=有效地址

3.指令是字长（或字长）的整数倍，不足的可以用0占位，也可以放在寻址方式码或者操作码的后面便于扩充

<font color='cornflowerblue'>T 求访问存储器（只算内存，寄存器不算）次数：</font>注意<font color='red'>指令也存在内存中，结果可能存在内存中</font>，都要算，不能只算操作数，指令长度/访问宽度=取指令的访问次数

指令长度、数据长度一般是字或半字长度的整数倍，地址空间/编址单元的长度（按字还是字节编址，统一成Byte或者bit计算）=地址数量



#### 高级语言编译成汇编语言

汇编语言->机器代码：汇编，汇编器，高级语言->汇编语言：编译，编译器

存储的时候目的寄存器编号一般放在后面，但MIPS汇编语言中结果的存放位置一般写在最前面

C语言中的变量和常量都是存储在内存中的，只有特殊声明成寄存器变量才是存储在寄存器中的

变量赋值、计算：对于存储在内存中的变量要通过sw和lw存取

转移：MIPS的条件转移只有相等和不等两种情况，对于比大小的情况，先比较slt并记录标志位，然后根据标志位是否等于$zero来判断是否转移

顺序指向完成后还需要一次跳转，跳过else后的指令

```mips
beq  ... ,else
...
j exit
else: ...
exit: ...
```



循环：

```mips
Loop: beq  ... ,Exit
	  ...
	  j   Loop
Exit: ...
```



<font color='cornflowerblue'>T：写汇编程序</font>

<font color='red'>！！！</font>

1. 数组的寻址A[i]，<font color='red'>偏移量是i*4</font>：设数组的基地址存在$3，i存在`$5`中循环体内用变址寻址，可以做两次加法或左移两位，`add $7, $5, $5;  add $7, $7, $7;  add $7, $7, $3`

循环体外可以用基址寻址`lw $4, i*4($3);   add $1, $2, $4`

调用过程中的数据主要用寄存器和栈存储

2. 16位立即数：-32768~32767，超过这个范围就不能`add $7, $8, 65000`，可以用高位置位再加上低位`lui $9, high(65000)`; `add $9, $0, low(65000); add $7, $8, $9`
